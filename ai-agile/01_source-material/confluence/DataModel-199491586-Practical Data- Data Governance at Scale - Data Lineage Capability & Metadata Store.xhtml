---
source: https://maoperatingsystem.atlassian.net/spaces/DataModel/pages/199491586/Practical+Data+Data+Governance+at+Scale+-+Data+Lineage+Capability+Metadata+Store
confluence_id: 199491586
space: DataModel
version: 42
retrieved: 2026-02-03T11:20:54.508712
format: xhtml
content_hash: 74bf4f5fef41d0fa4d8b3a393aaac6e1
macro_structured_macro: 2
macro_image: 0
macro_link: 6
output_hash: 74bf4f5fef41d0fa4d8b3a393aaac6e1
---
<h1>Practical Data: Data Governance at Scale - Data Lineage Capability &amp; Metadata Store</h1>

<h2>About this Document</h2>

<p>This document forms part of a series proposing a target reference architecture for Data Governance at scale for large organizations with highly fragmented business processes and data flows, such as large financial institutions with multiple business lines, individual product-aligned platforms, and centralized functions like finance and risk management.  This document provides a deeper dive into one of the architectural components within the architecture.  Links to other documents in this series can also be found below.</p>

<p>This document specifically focuses on the Data Lineage Capability and Metadata Store components.</p>

<h2>Table of Contents</h2>

<p>This section lists information contained in this document</p>

<h2>Data Governance at Scale</h2>

<p>This section provides lists of other documents within this series</p>

<h2>Data Lineage Capability &amp; Metadata Store</h2>

<h3>Overview</h3>

<p>The Data Lineage Capabilities and Data Lineage metadata combined enable the organization to understand how data flows throughout the enterprise to deliver business value outputs.</p>

<p>In this reference architecture, we define Technical Lineage as the data dependency between one data element in a data flow and its dependencies.  For example, attribute A in system A depends on the combination of Attribute B in system 2 and attribute C in system 3.   As such, we define the direction of the relationship as being from the downstream attribute to the upstream attribute.   Lineage can exist between systems as well as within a system. Lineage is managed at the lowest level of technical data element, as defined in the Data Inventory model, i.e., an attribute. See <ac:link>
<ri:page ri:content-title="Practical Data: Data Governance At Scale - Data Inventory Capability and Metadata Store" ri:version-at-save="35" />
<ac:link-body>Practical Data: Data Governance At Scale - Data Inventory Capability and Metadata Store</ac:link-body>
</ac:link>
</p>

<p>We define Business Lineage as the data dependency between logical business definitions of data. Again, at the lowest level of the business data element hierarchy described in the Data Inventory Model.</p>

<h3>Assumptions</h3>

<p>Listed below are the series of input assumptions that led to the proposed reference architecture design included in this document.</p>

<ol start="1">
<li>
<p>Data Inventory information, which describes the list of physical and business attributes, is stored within the metadata repository component. See Data Inventory for the design of the technical and business hierarchy of data elements (i.e., system-&gt;scheme-&gt;catalog-&gt;attribute, etc.).</p>

</li>

<li>
<p>By definition, data lineage information only describes the flow of data within systems and across system boundaries. Although the data inventory discovery process may identify additional attributes (and associated schemas and systems, etc.) as dependencies that need to be added to the Inventory for future inventory discovery.</p>

</li>

<li>
<p>Technical lineage is defined as the relationship between two lowest-level attributes in the data inventory. Higher-level (i.e., system-to-system dependencies) can then be implied.</p>

</li>

<li>
<p>It may not always be possible to automatically discover technical lineage.  A method will be required to enable system applications to contribute lineage information manually.</p>

</li>

<li>
<p>Business lineage is defined as the associated (implied) lineage of the business data inventory.  Note that the business view can also &quot;prioritize&quot; technical lineage branches to represent the criticality of certain data flows.</p>

</li>

<li>
<p>By definition, Data Inventory processes DO NOT have access to data content - only schema and structural information.  Data Profiling and other Capabilities have access to data content.</p>

</li>

</ol>
<h3>Architecture</h3>

<h2>Data Lineage Metadata</h2>

<h3>Lineage Data Model Design</h3>

<p>Note: Data model designs are included for illustration purposes only and are styled as a graph database with nodes and relationships. This is provided for convenience only, to define a reference architecture for data governance at scale, and does not necessitate a specific data storage method, database technology, or implementation design. See <ac:link>
<ri:page ri:content-title="Practical Data: Data Governance at Scale - Conventions" ri:version-at-save="2" />
<ac:link-body>Practical Data: Data Governance at Scale - Conventions</ac:link-body>
</ac:link>
</p>

<h4>Technical Lineage Data Model Design</h4>

<p>Three basic scenarios to model data lineage between attributes.</p>

<ol start="1">
<li>
<p>
<strong>Pass-through</strong> - In pass-through situations, the downstream from the node is a replica of the upstream &quot;to&quot; attribute.</p>

</li>

<li>
<p>
<strong>Simple Transformation</strong> - In simple transformation situations, the downstream attribute is derived based on the transformation of a <em>
<strong>single</strong>
</em> upstream attribute</p>

</li>

<li>
<p>
<strong>Complex Transformations</strong> - In complex transformation situations, the downstream attribute is derived based on the transformation of <em>
<strong>two or more</strong>
</em> upstream attributes. In this situation, it is necessary to introduce a new node element to the data design to capture the data transformation rule.  It is an implementation decision to include this extra node for the other two scenarios.</p>

</li>

</ol>
<p>Data Model Diagram</p>

<h5>Node Elements</h5>

<p>Listed below are the minimum elements required to be stored as part of the data governance metadata node record.</p>

<h6>NodeType = LINEAGE, NodeSubType = TRANSFORM</h6>

<table data-layout="default">
<tbody>
<tr>
<th>
<p>
<strong>Element</strong>
</p>

</th>

<th>
<p>
<strong>Element Description</strong>
</p>

</th>

<th>
<p>
<strong>Example Value</strong>
</p>

</th>

</tr>

<tr>
<td>
<p>nodeID</p>

</td>

<td>
<p>The unique ID of the node</p>

</td>

<td>
<p>LIN000000001</p>

</td>

</tr>

<tr>
<td>
<p>
<em>nodeType</em>
</p>

</td>

<td>
<p>The type of node - in this case, LINEAGE</p>

</td>

<td>
<p>LINEAGE</p>

</td>

</tr>

<tr>
<td>
<p>
<em>nodeSubType</em>
</p>

</td>

<td>
<p>The subtype of the node - in this case, TRANSFORM</p>

</td>

<td>
<p>TRANSFORM</p>

</td>

</tr>

<tr>
<td>
<p>
<em>nodeName</em>
</p>

</td>

<td>
<p>The name of the node - in this case, it should be a sensible technical summary of the transformation rule</p>

</td>

<td>
<p>Convert from ISO2 to ISO3 Country Codes</p>

</td>

</tr>

<tr>
<td>
<p>
<em>nodeSpecification</em>
</p>

</td>

<td>
<p>The detailed specification of the node, in this case, the technical data transformation rule for complex data</p>

</td>

<td>
<p>See example below.</p>

</td>

</tr>

</tbody>
</table>

<ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="cf898c1b-ae3c-49b9-8e28-083b70db32b5"><ac:parameter ac:name="language">py</ac:parameter><ac:plain-text-body><![CDATA[# ISO2 -> ISO3 lookup table (partial sample, extend as needed)
ISO2_TO_ISO3 = {
    "US": "USA",
    "CA": "CAN",
    "GB": "GBR",
    "FR": "FRA",
    "DE": "DEU",
    # Add more codes as needed
}

def iso2_to_iso3(iso2_code: str) -> str:
    """
    Convert ISO2 country code to ISO3 using a lookup table.
    Args:
        iso2_code (str): Two-letter ISO2 country code (case-insensitive).
    Returns:
        str: ISO3 country code if found, else None.
    """
    if not iso2_code:
        return None
    return ISO2_TO_ISO3.get(iso2_code.upper())]]></ac:plain-text-body></ac:structured-macro>
<h5>Relationship Elements</h5>

<p>Listed below are the minimum elements required to be stored as part of a data governance metadata relationship record between two nodes.</p>

<h6>RelType = LINEAGE, RelSubType=DEPENDS_ON</h6>

<table data-layout="default">
<tbody>
<tr>
<th>
<p>
<strong>Element</strong>
</p>

</th>

<th>
<p />
</th>

<th>
<p>
<strong>Example Value</strong>
</p>

</th>

</tr>

<tr>
<td>
<p>relType</p>

</td>

<td>
<p>The type of relationship - in this case, LINEAGE</p>

</td>

<td>
<p>LINEAGE</p>

</td>

</tr>

<tr>
<td>
<p>relSubType</p>

</td>

<td>
<p>The subtype of relationship - in this case, DEPENDS_ON</p>

</td>

<td>
<p>DEPENDS_ON</p>

</td>

</tr>

<tr>
<td>
<p>relFrom</p>

</td>

<td>
<p>Lineage source node ID - i.e., the downstream node in the lineage flow</p>

</td>

<td>
<p>ATT000000001</p>

</td>

</tr>

<tr>
<td>
<p>relTo</p>

</td>

<td>
<p>Lineage dependency node ID - i.e., the upstream node in the lineage flow.</p>

</td>

<td>
<p>ATT000000002</p>

</td>

</tr>

<tr>
<td>
<p>relName</p>

</td>

<td>
<p>Relationship Name - in this case, a summary of the simple transformation rule</p>

</td>

<td>
<p>Convert from ISO2 to ISO3 Country Codes</p>

</td>

</tr>

<tr>
<td>
<p>relSpecification</p>

</td>

<td>
<p>The detailed specification of the relationship for passthrough and simple transformation situations, specified as technical transformation details.</p>

</td>

<td>
<p>See example below.</p>

</td>

</tr>

</tbody>
</table>

<ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="72c67ec5-7250-4990-ad3e-364da84cff8f"><ac:parameter ac:name="language">py</ac:parameter><ac:plain-text-body><![CDATA[# ISO2 -> ISO3 lookup table (partial sample, extend as needed)
ISO2_TO_ISO3 = {
    "US": "USA",
    "CA": "CAN",
    "GB": "GBR",
    "FR": "FRA",
    "DE": "DEU",
    # Add more codes as needed
}

def iso2_to_iso3(iso2_code: str) -> str:
    """
    Convert ISO2 country code to ISO3 using a lookup table.
    Args:
        iso2_code (str): Two-letter ISO2 country code (case-insensitive).
    Returns:
        str: ISO3 country code if found, else None.
    """
    if not iso2_code:
        return None
    return ISO2_TO_ISO3.get(iso2_code.upper())]]></ac:plain-text-body></ac:structured-macro>
<h2>Data Lineage (Discovery) Capability</h2>

<p>The Data Lineage Capability consists of two parts</p>

<ol start="1">
<li>
<p>Data Lineage Engine, which schedules and collects all the information from the individual collectors</p>

</li>

<li>
<p>Data Lineage Connectors are responsible for providing various mechanisms for collecting lineage information through a scalable framework.</p>

</li>

</ol>
<p>Definitionally, Lineage connectors are only intended to discover lineage information; however, they may also discover attributes that have yet to be identified through the Data Inventory process.   In these cases, the Data Lineage capability should forward these missing inventory items to the Data Inventory capability via the Orchestration capability for action. See <ac:link>
<ri:page ri:content-title="Practical Data: Data Governance At Scale - Data Inventory Capability and Metadata Store" ri:version-at-save="35" />
<ac:link-body>Practical Data: Data Governance At Scale - Data Inventory Capability and Metadata Store</ac:link-body>
</ac:link>
</p>

<h3>Lineage Data Connectors</h3>

<p>Data lineage discovery must be able to identify lineage information from various sources before contributing it to the data lineage metadata store within the Data Governance Metadata Repository.  This reference architecture design establishes an extensible &quot;Connector&quot; based framework where a variety of connectors can be added as needed to discovery the required lineage information.</p>

<p>As connectors will tend to be technology-aligned, it may be appropriate to couple Data Lineage collectors with Data Inventory connectors as a single instance per tech stack, i.e., a combined MSSQL Data Inventory and Data Lineage Connector.</p>

<h4>Self-Service Connectors</h4>

<p>Self-service connectors enable individuals to submit lineage information themselves, which, for one or more reasons, cannot be discovered automatically. Two</p>

<ul>
<li>
<p>
<strong>API Base Self-Service Connector</strong> - The API Self-Service Connector enables users and systems to submit data lineage information via an API service. This allows business applications to self-register their lineage information and keep up with changes automatically,</p>

</li>

<li>
<p>
<strong>End User Self Service Connector</strong> - The End User Self Service Connector allows users to interact with a webpage to define lineage between attributes within the inventory, ideally through the single data governance Front End (See xxxxxx)</p>

</li>

</ul>
<h4>Out of the Box Automated Lineage Connectors</h4>

<ul>
<li>
<p>
<strong>Data Transformation Engine Lineage Connectors</strong> - Data Transformation Engine connectors enable automated discovery of lineage information from industry-standard data transformation and pipeline tools.  Examples include Airflow,</p>

</li>

<li>
<p>
<strong>Database Engine Lineage Connectors</strong> - Database Engine Connectors directly connect to the underlying database engines and utilize the configuration details within these to facilitate the automated discovery of lineage information from industry-standard database technologies. Examples include Oracle, MSSQL, etc</p>

</li>

<li>
<p>
<strong>Code Reader Lineage Connectors</strong> - Code Reader Lineage Connectors enable automated discovery of lineage information by interpreting source code repositories of applications to understand system interactions.</p>

</li>

<li>
<p>
<strong>3rd Party Application Connectors</strong> - 3rd Party Application connectors directly integrate with specific 3rd party applications such as commercial CRM, ERP or other platforms, to utilize the internal configuration details of these platforms to facilitate automated discovery of lineage information.  Examples include Salesforce, SAP, Workday, Microsoft Dynamics, etc.</p>

</li>

</ul>
<h2>Advanced Capabilities</h2>

<p>The advanced capabilities are additional topics relating to data lineage that are not yet folded into the reference designs above. These are included for reference only in the latest trends and discussions topic relating to Data Lineage.</p>

<h3>Context-Aware Data Lineage</h3>

<p>Context-aware data lineage is the latest iteration of data lineage capability in the data governance space. Data lineage traces a single understanding of the flow of data throughout an environment to establish a business output.   For simplicity, let's consider a single business outcome, and we aim to trace data lineage through the systems to a specific data element on the report.</p>

<p>&quot;Traditional&quot; data lineage takes a &quot;column&quot; based view of data lineage and performs well when all data in a column follows the same path to the endpoint destination.   However, in many large organizations, the path that data flows through an environment depends on the context of the data or a specific row in the report.  For example, if an exposures report includes data from two product lines, the exposures column in the report for product A could follow one path and the exposure column for product B another. Golden record data within reference data master data management platforms is often a combination of data from multiple sources, combined in real-time. This is another example of context-aware data lineage, where the current data content is also a result.</p>

<p>Context-aware lineage enables lineage graphs to consider the context of the output report recordsets, which is typically defined at a high-level organizational level. For example, context could be a combination of one or more of the products, regions, business lines, etc.</p>

<h2>Record Level Lineage (Data Tracing)</h2>